# 核心类
Context:调用链上下文，贯穿一次调用链路中的所有Entry。
- Context维护入口节点(entranceNode)，本次调用节点(curNode)，调用来源(origin)。等信息
- Context名称即为调用链入口名称

Entry：每一次资源调用都会创建一个Entry
- 包含了资源名、curNode(当前统计节点)、originNode(来源统计节点)等信息。
- CtEntry：在调用`SphU.entry()`时创建，构造函数会做调用链的变换，内部维护着parent,child。

StatisticSlot（统计槽）：用于根据规则判断结果进行相应的统计操作



# 资源定义方式
1.SphU的try-catch方式 - 框架使用
2.SphO的if-else方式 - 框架使用
3.@SentinelResource方式 - 一般业务使用


# 动态规则扩展
扩展方式：
1. 手动通过API调用`loadRules()`加载新规则
2. 通过DataSource适配不同数据源修改。
   1. 拉模式：客户端主动向规则管理中心定期轮询拉取规则。规则中心可以是RDBMS,文件，VCS等。缺点无法及时获取变更，目前支持动态文件数据源、Consul、Eureka
   2. push模式：规则中心推送，客户端通过注册监听器坚挺规则变化，例如：ZK,Redis,Nacos,Apollo,etcd
3. 通过控制台设置规则，在推送到统一的规则中心，客户端实现 ReadableDataSource接口监听规则中心实时获取变更。

扩展实践：
- pull模式：继承AutoRefreshDataSource抽象类，实现readSource()方法，从指定数据源读取字符串格式的配置数据
- push模式：继承AbstractDataSource抽象类，在其构造器中添加监听器，并实现readSource()从指定数据源读取字符串格式的配置数据
- 注册数据源：
  - 手动注册数据源
  - SPI 自动发现: InitFunc接口。